// Code generated by gencel. DO NOT EDIT.

package funcs

import "github.com/google/cel-go/cel"
import "github.com/google/cel-go/common/types"
import "github.com/google/cel-go/common/types/ref"

var cryptoPBKDF2Gen = cel.Function("crypto.PBKDF2",
	cel.Overload("crypto.PBKDF2_interface{}_interface{}_interface{}_interface{}_string",

		[]*cel.Type{
			cel.DynType, cel.DynType, cel.DynType, cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			list := transferSlice[string](args[4].(ref.Val))

			a0, a1 := x.PBKDF2(args[0], args[1], args[2], args[3], list...)
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoWPAPSKGen = cel.Function("crypto.WPAPSK",
	cel.Overload("crypto.WPAPSK_interface{}_interface{}",

		[]*cel.Type{
			cel.DynType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.WPAPSK(args[0], args[1])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoSHA1Gen = cel.Function("crypto.SHA1",
	cel.Overload("crypto.SHA1_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA1(args[0]))

		}),
	),
)

var cryptoSHA224Gen = cel.Function("crypto.SHA224",
	cel.Overload("crypto.SHA224_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA224(args[0]))

		}),
	),
)

var cryptoSHA256Gen = cel.Function("crypto.SHA256",
	cel.Overload("crypto.SHA256_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA256(args[0]))

		}),
	),
)

var cryptoSHA384Gen = cel.Function("crypto.SHA384",
	cel.Overload("crypto.SHA384_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA384(args[0]))

		}),
	),
)

var cryptoSHA512Gen = cel.Function("crypto.SHA512",
	cel.Overload("crypto.SHA512_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA512(args[0]))

		}),
	),
)

var cryptoSHA512_224Gen = cel.Function("crypto.SHA512_224",
	cel.Overload("crypto.SHA512_224_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA512_224(args[0]))

		}),
	),
)

var cryptoSHA512_256Gen = cel.Function("crypto.SHA512_256",
	cel.Overload("crypto.SHA512_256_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.StringType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			return types.DefaultTypeAdapter.NativeToValue(x.SHA512_256(args[0]))

		}),
	),
)

var cryptoSHA1BytesGen = cel.Function("crypto.SHA1Bytes",
	cel.Overload("crypto.SHA1Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.SHA1Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoSHA224BytesGen = cel.Function("crypto.SHA224Bytes",
	cel.Overload("crypto.SHA224Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.SHA224Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoSHA256BytesGen = cel.Function("crypto.SHA256Bytes",
	cel.Overload("crypto.SHA256Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.SHA256Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoSHA384BytesGen = cel.Function("crypto.SHA384Bytes",
	cel.Overload("crypto.SHA384Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.SHA384Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoSHA512BytesGen = cel.Function("crypto.SHA512Bytes",
	cel.Overload("crypto.SHA512Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.SHA512Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoSHA512_224BytesGen = cel.Function("crypto.SHA512_224Bytes",
	cel.Overload("crypto.SHA512_224Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.SHA512_224Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoSHA512_256BytesGen = cel.Function("crypto.SHA512_256Bytes",
	cel.Overload("crypto.SHA512_256Bytes_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.SHA512_256Bytes(args[0])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoBcryptGen = cel.Function("crypto.Bcrypt",
	cel.Overload("crypto.Bcrypt_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			list := transferSlice[interface{}](args[0].(ref.Val))

			a0, a1 := x.Bcrypt(list...)
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoRSAEncryptGen = cel.Function("crypto.RSAEncrypt",
	cel.Overload("crypto.RSAEncrypt_string_interface{}",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.RSAEncrypt(args[0].Value().(string), args[1])
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoRSADecryptGen = cel.Function("crypto.RSADecrypt",
	cel.Overload("crypto.RSADecrypt_string_[]byte",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.RSADecrypt(args[0].Value().(string), args[1].Value().([]byte))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoRSADecryptBytesGen = cel.Function("crypto.RSADecryptBytes",
	cel.Overload("crypto.RSADecryptBytes_string_[]byte",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.RSADecryptBytes(args[0].Value().(string), args[1].Value().([]byte))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoRSAGenerateKeyGen = cel.Function("crypto.RSAGenerateKey",
	cel.Overload("crypto.RSAGenerateKey_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			list := transferSlice[interface{}](args[0].(ref.Val))

			a0, a1 := x.RSAGenerateKey(list...)
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoRSADerivePublicKeyGen = cel.Function("crypto.RSADerivePublicKey",
	cel.Overload("crypto.RSADerivePublicKey_string",

		[]*cel.Type{
			cel.StringType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.RSADerivePublicKey(args[0].Value().(string))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoECDSAGenerateKeyGen = cel.Function("crypto.ECDSAGenerateKey",
	cel.Overload("crypto.ECDSAGenerateKey_interface{}",

		[]*cel.Type{
			cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			list := transferSlice[interface{}](args[0].(ref.Val))

			a0, a1 := x.ECDSAGenerateKey(list...)
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoECDSADerivePublicKeyGen = cel.Function("crypto.ECDSADerivePublicKey",
	cel.Overload("crypto.ECDSADerivePublicKey_string",

		[]*cel.Type{
			cel.StringType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs

			a0, a1 := x.ECDSADerivePublicKey(args[0].Value().(string))
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoEncryptAESGen = cel.Function("crypto.EncryptAES",
	cel.Overload("crypto.EncryptAES_string_interface{}",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			list := transferSlice[interface{}](args[1].(ref.Val))

			a0, a1 := x.EncryptAES(args[0].Value().(string), list...)
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoDecryptAESGen = cel.Function("crypto.DecryptAES",
	cel.Overload("crypto.DecryptAES_string_interface{}",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			list := transferSlice[interface{}](args[1].(ref.Val))

			a0, a1 := x.DecryptAES(args[0].Value().(string), list...)
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)

var cryptoDecryptAESBytesGen = cel.Function("crypto.DecryptAESBytes",
	cel.Overload("crypto.DecryptAESBytes_string_interface{}",

		[]*cel.Type{
			cel.StringType, cel.DynType,
		},
		cel.DynType,
		cel.FunctionBinding(func(args ...ref.Val) ref.Val {

			var x CryptoFuncs
			list := transferSlice[interface{}](args[1].(ref.Val))

			a0, a1 := x.DecryptAESBytes(args[0].Value().(string), list...)
			return types.DefaultTypeAdapter.NativeToValue([]any{
				a0, a1,
			})

		}),
	),
)
